import re
import sys
import pathlib


def matches(name, includes):
    return name in includes or '@all' in includes

def find_tests_in_file(path, includes):
    matched = False

    with open(path, "r") as f:
        for line in f:
            if re.match(r'litmus_test_t .+\s*=\s*{\s*', line):
                # litmus_test_t name = {
                _, __, rem = line.partition(" ")
                cname, _, __ = rem.partition("=")

                # try find test name to see if it should be excluded
                # this is pretty horrible and assumes the test name is the first "double quoted string"
                # on one of the successor lines
                while True:
                    line = next(f)
                    if '"' in line:
                        _, _, rem = line.partition('"')
                        testname, _, _ = rem.partition('"')
                        break

                if not matches(testname, includes):
                    continue

                matched = True
                yield cname.strip()

    if matched:
        print(str(path))



def get_tests(d, includes):
    for f in d.iterdir():
        if f.is_dir():
            subtests = list(get_tests(f, ['@all'] if matches('@'+f.name, includes) else includes))
            if subtests:
                yield (f.name, subtests)
        elif f.suffix == '.c':
            yield from find_tests_in_file(f, includes)


def split_tests(tests_and_groups):
    tests = []
    groups = {}

    for t in tests_and_groups:
        if isinstance(t, tuple):
            (grp_name, sub_tests_and_groups) = t
            groups[grp_name] = split_tests(sub_tests_and_groups)
        else:
            tests.append(t)

    return (tests, groups)


group_template = """
const litmus_test_group grp_%s = {
  .name="@%s",
  .tests = (const litmus_test_t*[]){
    %s
  },
  .groups = (const litmus_test_group*[]){
    %s
  },
};\
"""


def build_group_defs(name, split_groups):
    (tests, subgroups) = split_groups

    for grp_name, split_sub_group in subgroups.items():
        yield from build_group_defs(grp_name, split_sub_group)

    test_refs = sorted('&{}'.format(tname) for tname in tests)
    grp_refs = sorted('&grp_{}'.format(gname) for gname in subgroups)
    test_refs.append('NULL')
    grp_refs.append('NULL')
    yield group_template % (name, name, ',\n    '.join(test_refs), ',\n    '.join(grp_refs))


def all_tests(split_groups):
    (tests, sub) = split_groups
    yield from tests
    for grp in sub.values():
        yield from all_tests(grp)


def build_externs(split_groups):
    all = sorted(all_tests(split_groups))
    externs = ',\n  '.join(all)
    return 'extern litmus_test_t\n  {};'.format(externs)


code_template="""\
/************************
 *  AUTOGENERATED FILE  *
 *     DO NOT EDIT      *
 ************************/

 /* this file was generated with the following command:
  * `make LITMUS_TESTS='{includes}'`
  *
  * please re-run that command to re-generate this file
  */
#include "lib.h"

%s

%s
""".format(includes=' '.join(sys.argv[1:]))


def build_code(root_dir, includes=['@all']):
    tests = get_tests(root_dir, includes)
    splitted = split_tests(tests)
    extern_line = build_externs(splitted)
    litmus_group_defs = build_group_defs("all", splitted)
    return code_template % (extern_line, '\n'.join(litmus_group_defs))


if __name__ == "__main__":
    includes = set(sys.argv[1:])
    root = pathlib.Path(__file__).parent
    code = build_code(root / 'litmus_tests/', includes=includes)
    with open(root / 'groups.c', 'w') as f:
        f.write(code)
import re
import sys
import pathlib

TEST_FILES = []
UPDATED_FILES = []
NO_PRINT = set()

def matches(name, includes):
    return name in includes or '@all' in includes

def find_tests_in_file(path, includes):
    matched = False

    with open(path, "r") as f:
        for line in f:
            if re.match(r'litmus_test_t .+\s*=\s*{\s*', line):
                # litmus_test_t name = {
                _, __, rem = line.partition(" ")
                cname, _, __ = rem.partition("=")

                # try find test name to see if it should be excluded
                # this is pretty horrible and assumes the test name is the first "double quoted string"
                # on one of the successor lines
                while True:
                    line = next(f)
                    if '"' in line:
                        _, _, rem = line.partition('"')
                        testname, _, _ = rem.partition('"')
                        break

                if not matches(testname, includes):
                    continue

                matched = True
                yield cname.strip()
                break  # assume 1 per file

    if matched:
        if not quiet and str(path) not in NO_PRINT:
            UPDATED_FILES.append(str(path))
            sys.stderr.write('   (COLLECT) {}\n'.format(str(path)))
        TEST_FILES.append(str(path))


def get_tests(d, includes):
    for f in d.iterdir():
        if f.is_dir():
            subtests = list(get_tests(f, ['@all'] if matches('@'+f.name, includes) else includes))
            if subtests:
                yield (f.name, subtests)
        elif f.suffix == '.c':
            yield from find_tests_in_file(f, includes)


def split_tests(tests_and_groups):
    tests = []
    groups = {}

    for t in tests_and_groups:
        if isinstance(t, tuple):
            (grp_name, sub_tests_and_groups) = t
            groups[grp_name] = split_tests(sub_tests_and_groups)
        else:
            tests.append(t)

    return (tests, groups)


group_template = """
const litmus_test_group grp_%s = {
  .name="@%s",
  .tests = (const litmus_test_t*[]){
    %s
  },
  .groups = (const litmus_test_group*[]){
    %s
  },
};\
"""


def build_group_defs(name, split_groups):
    (tests, subgroups) = split_groups

    for grp_name, split_sub_group in subgroups.items():
        yield from build_group_defs(grp_name, split_sub_group)

    test_refs = sorted('&{}'.format(tname) for tname in tests)
    grp_refs = sorted('&grp_{}'.format(gname) for gname in subgroups)
    test_refs.append('NULL')
    grp_refs.append('NULL')
    yield group_template % (name, name, ',\n    '.join(test_refs), ',\n    '.join(grp_refs))


def all_tests(split_groups):
    (tests, sub) = split_groups
    yield from tests
    for grp in sub.values():
        yield from all_tests(grp)


def build_externs(split_groups):
    all = sorted(all_tests(split_groups))
    externs = ',\n  '.join(all)
    return 'extern litmus_test_t\n  {};'.format(externs)


code_template="""\
/************************
 *  AUTOGENERATED FILE  *
 *     DO NOT EDIT      *
 ************************/

 /* this file was generated with the following command:
  * `make LITMUS_TESTS='{includes}'`
  *
  * please re-run that command to re-generate this file
  */
#include "lib.h"

%s

%s
"""


def build_code(root_dir, includes=['@all']):
    tests = get_tests(root_dir, includes)
    splitted = split_tests(tests)
    extern_line = build_externs(splitted)
    litmus_group_defs = build_group_defs("all", splitted)
    return code_template.format(includes=' '.join(includes)) % (extern_line, '\n'.join(litmus_group_defs))

def read_previous_includes(root):
    try:
        with open(root / 'test_list.txt', 'r') as f:
            header = set(f.readline().strip().split())
            for line in f:
                NO_PRINT.add(line.strip())
            return header
    except FileNotFoundError:
        sys.stderr.write('Warning: LITMUS_TESTS not set, populating with @all\n')
        return {'@all'}

if __name__ == "__main__":
    root = pathlib.Path(__file__).parent

    quiet = sys.argv[1]
    quiet, _, _separator = quiet.partition('=')
    if _separator:
        separator = _separator
    quiet = int(quiet)

    includes = set(sys.argv[2:])
    if includes == set():
        includes = read_previous_includes(root)

    code = build_code(root / 'litmus_tests/', includes=includes)

    if UPDATED_FILES:
        # only update groups.c if we actually changed the file
        with open(root / 'groups.c', 'w') as f:
            f.write(code)

    with open(root / 'test_list.txt', 'w') as f:
        f.write(' '.join(includes) + '\n')
        f.write('\n'.join(TEST_FILES))